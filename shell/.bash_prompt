# Config for shell prompt

# Lotta stuf here was stolen from github.com/mathiasbynens/dotfiles

if [[ $COLORTERM = gnome-* && $TERM = xterm ]] && infocmp gnome-256color >/dev/null 2>&1; then
    export TERM='gnome-256color';
    elif infocmp xterm-256color >/dev/null 2>&1; then
        export TERM='xterm-256color';
fi;


git_info() {
    local branchName=''
    local s=''
    local git_toplevel=$(git rev-parse --show-toplevel 2>/dev/null)

    # Am I in a git repo?
    if [ -n "${git_toplevel}" ] && [ "${git_toplevel}" != "${HOME}" ]; then
        
        local git_branch=$(git rev-parse --abbrev-ref HEADi 2>/dev/null)

        if [ -n "${git_branch}" ] && [ "${git_branch}" != 'master' ]; then
            if [ "${git_branch}" == 'HEAD' ]; then
                git_branch=$(git rev-parse --short HEAD 2>/dev/null)
            fi
            if [ -n "${git_branch}" ]; then
                branchName="${git_branch}"
            fi
        fi
            
        # Ensure the index is up to date.
        git update-index --really-refresh -q &>/dev/null;

        # Check for uncommitted changes in the index.
        if ! $(git diff --quiet --ignore-submodules --cached); then
            s+='+';
        fi;
        
        # Check for unstaged changes.
        if ! $(git diff-files --quiet --ignore-submodules --); then
            s+='!';
        fi;
        # Check for untracked files.
        if [ -n "$(git ls-files --others --exclude-standard)" ]; then
            s+='?'
        fi;
        # Check for stashed files.
        if $(git rev-parse --verify refs/stash &>/dev/null); then
            s+='$';
        fi;
        
    fi;
            
    [ -n "${s}" ] && s=" [${s}]";
        
    echo "| ${1}${branchName}${2}${s}";
}


# set the prompt string:
PS1="\u@\h" # user @hostname
PS1+="$(git_info)" # git repo stuff
PS1+="\n\w$ " # working directory and prompt

